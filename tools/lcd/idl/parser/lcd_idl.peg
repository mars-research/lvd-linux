start-symbol: File
options: debug9

include: {{ #include "../include/lcd_ast.h"
	    #include <vector>
	    #include <stdlib.h>
	    #include <string>
	    #include <stdint.h> }}

code: {{
      static FileScope* fs_instance;
      FileScope* current_file_scope()
      {
	if(!fs_instance)
	{
		fs_instance = new FileScope(RootScope::instance());
	}
	return fs_instance;
      }
      Type * getType(const char* type)
      {	   
      	   int * err;
      	   RootScope* rs = RootScope::instance();
	   Type* val = rs->lookup_symbol(type, err);
	   if(!*err)
	   { // error do something
}
	    return val;
      }				

      void insertType(char * sym, Type * val) // should this be void?
      {
	FileScope *fs = current_file_scope();
	int ret = fs->insert_symbol(sym, val);
	if(!ret)
	{ // error do something 
	}
	
      }	
}}

rules:

Identifier	=	i1:IdentStart i2:IdentCont* Spacing {{ 
			std::ostringstream total;
			total << (char) (intptr_t) i1.getValue();

		   	for(Value::iterator it = i2.getValues().begin(); it != i2.getValues().end(); it ++)
		   	{
				const Value & v = *it;
				char letter = (char) (intptr_t) v.getValue();
				total << letter;
		   	}
				std::string str = total.str();
		   		value = &str[0]; }}

IdentStart	=	[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]

IdentCont	=	IdentStart | [0123456789]

File		=	Spacing v:Verbatim? t:Things* <eof> {{
			std::vector<Rpc *>* rpcs = new std::vector<Rpc *>;
			for(Value::iterator it = t.getValues().begin(); it != t.getValues().end(); it ++)
			{
				const Value & v = *it;
				Rpc * rp = (Rpc *) v.getValue();
				rpcs->push_back(rp);

			}
			  value = new File((char*) v.getValue(), current_file_scope(), rpcs); }}

Typedef		=	 "typedef" Spacing "<" Spacing rt:RealType Spacing "," Spacing mt:Type_form Spacing ">" Spacing id:Identifier Spacing {{ 
			 Typedef * val = new Typedef((char*) rt.getValue(), (Type*) mt.getValue());
			 insertType((char*)id.getValue(),val);
			 }}

Verbatim	=	 "verbatim" Spacing "[" contents:VerbatimContent "]" {{ std::ostringstream total;
			for(Value::iterator it = contents.getValues().begin(); it != contents.getValues().end(); it ++)
			{
			const Value &v = *it;
			char letter = (char) (intptr_t) v.getValue();
			total << letter;     
			}
			std::string str = total.str();
			value = &str[0]; }}

VerbatimContent =	!"]" .

RealType	=	fp:Identifier? Spacing sp:Identifier {{ //temporary solution
			std::ostringstream total;
			total << fp.getValue() << ' ' << sp.getValue();
			std::string str = total.str();
			value = &str[0];
			}}		

String		=	<ascii 34> l:any_letter+ <ascii 34> {{
			std::ostringstream total;
			for(Value::iterator it = l.getValues().begin(); it != l.getValues().end(); it ++)
			{
				const Value & v = *it;
				char letter = (char) (intptr_t) v.getValue();
				
				if(letter == '\\')
				{
					if((it++) == l.getValues().end())
					{
						total << letter;
						break;
					}	
					
					letter = (char) (intptr_t) (*it).getValue();
					switch (letter)
					{
					case 'n':
					     total <<'\n';
					     break;
					case 't':
					     total << '\t';
					     break;
					default:
						total << letter;
					}
					continue;
				}
				total << letter;
			}
			std::string str = total.str();
			value = &str[0]; }}

any_letter	=	[_.,/?<>'; =:%`!@#$^&*()-+{}|\\ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789]

Things		=	Typedef | Rpc | Projection

Include		=	"#include" Space+ "<" Spacing f:Identifier Spacing ">" Spacing {{
			std::ostringstream total;
			total << "#include <" << (char *) f.getValue() << ">";
			std::string str = total.str();
			value = &str[0]; }}
			
			| "#include" Space+ s:String Spacing {{
			std::ostringstream total;
			total << "#include " << (char *) s.getValue();
			std::string str = total.str();
			value = &str[0]; }}

FirstParam	=	t:Type_form id:Identifier Spacing COMMA Spacing {{
			value = new Parameter((Type *) t.getValue(), (char *) id.getValue()); }} 
			  

LastParam	=	t:Type_form id:Identifier Spacing {{
			value = new Parameter((Type *) t.getValue(), (char *) id.getValue()); }}

Parameters	=	f:FirstParam* l:LastParam {{
			std::vector<Parameter* >* params = new std::vector<Parameter* >;
			for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++)
			{ 
				const Value & v = *it;
				Parameter* p = (Parameter* ) v.getValue();
				params->push_back(p);
			}
			params->push_back((Parameter* ) l.getValue());
			value = params; }}

Rpc		=	"rpc" Space+ t:Type_form id:Identifier Spacing OPEN p:Parameters CLOSE SEMI Spacing {{
			value = new Rpc((Type *) t.getValue(), (char *) id.getValue(), (std::vector<Parameter *> *) p.getValue()); }}  




Projection	=	"projection" Space+ id:Identifier "<" Spacing t:Proj_type ">" Spacing OPENC Spacing p:ProjField+ CLOSEC Spacing {{ std::vector<ProjectionField *>* p_fields = new std::vector<ProjectionField *>;
			for(Value::iterator it = p.getValues().begin(); it != p.getValues().end(); it ++)
			{
				const Value & v = *it;
				ProjectionField * p = (ProjectionField *) v.getValue();
				p_fields->push_back(p);
			} 
			// insert projection into rootscope for now
			ProjectionType * val = new ProjectionType((char* ) id.getValue(), (char* ) t.getValue(), p_fields);
			insertType((char*)id.getValue(), val);
			 }}
		## what is the point of having a projection without at least one line

Proj_type	=  	"struct" Space+ id:Identifier Spacing {{
			std::ostringstream total;
			total << "struct " << (char *) id.getValue();
			std::string str = total.str();
			value = &str[0]; }}

Keyword		=     	"out" {{ int * x = (int *) malloc(sizeof(int));
			      *x = 1;
			      value = x; }}
			| "in" {{ int * x = (int *) malloc(sizeof(int));
			       *x = 2; 
			       value = x; }}
			| "bind" {{ int * x = (int *) malloc(sizeof(int));
			  	 *x = 3; 
			  	 value = x; }}
			| "alloc" {{ int * x = (int *) malloc(sizeof(int));
			  	  *x = 4;
				  value = x; }}
			
Start		=	k:Keyword Spacing COMMA Spacing {{ value = k; }}

Specification	=	s:Start* l:Last {{
			std::vector<bool> specs (4, false);
			for(Value::iterator it = s.getValues().begin(); it != s.getValues().end(); it ++)
			{
				const Value & v = *it;
				int* x = (int*) v.getValue();
				if(!x)
				{
					printf("error x is null\n");
					exit(0);       
				}
				specs[*x -1] = true;
				 
			}
			int * y = (int *) l.getValue();
			if(!y) { printf("error y is null\n"); exit(0); }
			specs[*y-1] = true;
			value = &specs; }}

ProjField	=	OPENS Spacing s:Specification CLOSES Spacing t:Type_form id:Identifier SEMI Spacing {{ int * spec = (int *)s.getValue();
			bool in = false; bool out = false; bool bind = false; bool alloc = false;
			std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			int i = 0;
			for(std::vector<bool>::iterator it = specs->begin(); it != specs->end(); it ++)
			{
				if(*it)
				{
				if(i == 0)
				     out = true;
				else if(i == 1)
				     in = true;
				else if(i == 2)
				     bind = true;
				else
					alloc = true;
				}			
			}
			value = new ProjectionField(in, out, alloc, bind, (Type *) t.getValue(), (char *) id.getValue()); }}


Last		=	k:Keyword Spacing {{ value = k; }}

Option		=	"projection"

Comment		=	Comment_start Comment_rest

Comment_rest	=	Comment_end
			| . Comment_rest

Comment_start	=	"/*"
Comment_end	=	"*/"


Line_comm_rest	=	Line_comm_end
			| . Line_comm_rest

Line_comm_start	=	"//"

Line_comment	=	Line_comm_start Line_comm_rest


Line_comm_end	=	"\n"

signed_type	=	"int" {{ value = getType("int");}}
			| "char" {{ value = getType("char"); }}   
			| "capability" {{ value = getType("capability"); }}
			| "short" {{ value = getType("short");}}
			| "long" Space+ "long" {{ value = getType("long long");}}
			| "long" {{ value = getType("long"); }}

unsigned_type	=	"unsigned" Space+ "int" {{ value = getType("unsigned int"); }} 
			| "unsigned" Space+ "char" {{ value = getType("unsigned char"); }} 
			| "unsigned" Space+ "short" {{ value = getType("unsigned long"); }} 
			| "unsigned" Space+ "long" Space+ "long" {{ value = getType("unsigned long long"); }}
			| "unsigned" Space+ "long" {{ value = getType("unsigned long"); }}  

type 		=	unsigned_type
			| signed_type

## just ignore the modules ones, not supporting right now

Type_form	=	"projection" Space+ m:Identifier "::" name:Identifier Spacing "*" Spacing
			| "projection" Space+ m:Identifier "::" name:Identifier Space+
			| "projection" Space+ name:Identifier Spacing "*" Spacing {{
			value = new PointerType(getType((char*)name.getValue())); }}
			| "projection" Space+ name:Identifier Space+ {{ 
			  value = getType((char*)name.getValue()); }}
			| type	

Spacing		=	Space*

Space		=	" " | "\t" | EndOfLine
EndOfLine	=	"\n" | "\r"

OPEN		=	"("
CLOSE		=	")"
SEMI		=	";"	
OPENC		=	"{"
CLOSEC		=	"}"
OPENA		=	"<"
CLOSEA		=	">"
OPENS		=	"["
CLOSES		=	"]"
COMMA		=	","